<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pandas 多线程数据处理</title>
      <link href="/myblog/2021/05/19/pandas-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/myblog/2021/05/19/pandas-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>最近业务需要处理一批表格数据。处理过程中，成千上万条数据都需要进行i/o读写，自然而然要用到并发编程。</p><p>python并发编程主要包括以下三种：</p><ol><li><p>多进程：主要用于处理cpu密集型任务。</p></li><li><p>多线程：主要用于处理i/o密集型任务.</p></li><li><p>协程：为了解决2) 线程之间切换资源开销浪费而产生，又叫微线程， 通常和多进程配合使用， 效果奇佳。</p></li></ol><p>这里详细概念、用法不作赘述， 笔者当年学习的时候看过几篇不错的入门， 地址这里给出。</p><p><a href="https://zhuanlan.zhihu.com/p/46798399">爱coding：python并行计算（上）：multiprocessing、multiprocess模块</a></p><p><a href="https://zhuanlan.zhihu.com/p/46368084">一文看懂Python多进程与多线程编程(工作学习面试必读)</a></p><p><a href="https://zhuanlan.zhihu.com/p/64702600">一篇文章搞定Python多进程(全)</a></p><p><a href="https://zhuanlan.zhihu.com/p/70256971">【面试高频问题】线程、进程、协程</a></p><p>因为是处理i/o密集型任务，这里采用第二种并发方式(其实是笔者没玩过协程哈哈)。废话不多说， 直接上核心框架:</p><pre><code class="python">from threading import Threadimport pandas as pdclass MyThread(Thread):    def __init__(self, group=None, target=None, name=None,                 args=(), kwargs=None, *, daemon=None) -&gt; None:   #这里定义直接copy Thread类里原生定义        super().__init__(group=group, target=target,                         name=name, args=args,                         kwargs=kwargs, daemon=daemon)      def run(self) -&gt; None:        try:            if self._target:                self.result = self._target(*self._args, **self._kwargs) #与Thread类唯一不同的是， 我们用类内属性result保存每个线程结果        finally:            del self._target, self._args, self._kwargsif __name__ == '__main__':    ThreadPool = []    for i in iterator:  #伪代码， 表示一个迭代器生成多个任务        ThreadPool.append(MyThread(arget=func, args=(*args,)))      # 线程池中添加一个线程    # 注意这个线程池是一个广义的概念    # 你可以用任意数据结构来实现    # 方便存入、操作线程对象即可    for p in ThreadPool:        p.start()    for p in ThreadPool:        p.join()    df = pd.concat([p.result for p in ThreadPool]) #把所有线程处理结果合并成要一个表格</code></pre><p>这里注意__init__参数中， 有一个参数为*，这里参见前面文章<br><a href="https://zhuanlan.zhihu.com/p/372492539">Python形参中*的作用(非*args，**kwargs)</a></p><p>网上很多线程实现方案里， 都完全重写了<strong>init</strong> 和 run 方法， 把私货写进去。 笔者个人觉得， 官方库既然最原始这样写， 自然有它的道理。 我们在继承对象的时候， 要尽量少做改动， 尽量把自定义的东西(比方说任务)放在外面输入进API就可以了。下面实现一个简单的任务，使用广度优先(bfs，最大深度默认为3，要不然时间略长)统计系统(Win)各个磁盘文件路径、大小以及创建时间。</p><pre><code class="python">def func(rootpath, maxdepth=3):    df = pd.DataFrame()    filepaths = [(rootpath, 0)]  #维护一个队列， 每个路径附带一个深度值    while len(filepaths) != 0:        cur_path, cur_depth = filepaths.pop(0)        if cur_depth &gt;= maxdepth:  #深度达到最大深度停止搜索            idx = len(df)              df.loc[idx, 'path'] = os.path.join(cur_path)  #记录路径            df.loc[idx, 'date'] = os.path.getctime(cur_path)  #记录时间            df.loc[idx, 'size'] = os.path.getsize(cur_path)  #记录文件大小        else:            try:  #这个纯粹是因为Win系统有些路径不让访问报OSError， 哪怕开了管理员权限                subfiles = os.listdir(cur_path)                for f in subfiles:                    subfpath = os.path.join(cur_path, f)                    if os.path.isdir(subfpath):                        filepaths.append((subfpath, cur_depth+1))  #如果是文件夹, 继续bfs搜索                    else:                        idx = len(df)                        df.loc[idx, 'path'] = os.path.join(subfpath)                        df.loc[idx, 'date'] = os.path.getctime(subfpath)                        df.loc[idx, 'size'] = os.path.getsize(subfpath)            except OSError:                pass    return df</code></pre><p>下面上完整代码：</p><pre><code class="python"># -*- coding: utf-8 -*- import datetimeimport osimport timefrom threading import Threadimport pandas as pddef func(rootpath, maxdepth=3):    df = pd.DataFrame()    filepaths = [(rootpath, 0)]  #维护一个队列， 每个路径附带一个深度值    while len(filepaths) != 0:        cur_path, cur_depth = filepaths.pop(0)        if cur_depth &gt;= maxdepth:  #深度达到最大深度停止搜索            idx = len(df)              df.loc[idx, 'path'] = os.path.join(cur_path)  #记录路径            df.loc[idx, 'date'] = os.path.getctime(cur_path)  #记录时间            df.loc[idx, 'size'] = os.path.getsize(cur_path)  #记录文件大小        else:            try:  #这个纯粹是因为Win系统有些路径不让访问报OSError， 哪怕开了管理员权限                subfiles = os.listdir(cur_path)                for f in subfiles:                    subfpath = os.path.join(cur_path, f)                    if os.path.isdir(subfpath):                        filepaths.append((subfpath, cur_depth+1))  #如果是文件夹, 继续bfs搜索                    else:                        idx = len(df)                        df.loc[idx, 'path'] = os.path.join(subfpath)                        df.loc[idx, 'date'] = os.path.getctime(subfpath)                        df.loc[idx, 'size'] = os.path.getsize(subfpath)            except OSError:                pass    return dfclass MyThread(Thread):    def __init__(self, group=None, target=None, name=None,                 args=(), kwargs=None, *, daemon=None) -&gt; None:   #这里定义直接copy Thread类里原生定义        super().__init__(group=group, target=target,                         name=name, args=args,                         kwargs=kwargs, daemon=daemon)      def run(self) -&gt; None:        try:            if self._target:                self.result = self._target(*self._args, **self._kwargs) #与Thread类唯一不同的是， 我们用类内属性result保存每个线程结果        finally:            del self._target, self._args, self._kwargsif __name__ == '__main__':    ThreadPool = []    ThreadPool.append(MyThread(target=func, args=('c:/', 3)))    ThreadPool.append(MyThread(target=func, args=('d:/', 3)))    ThreadPool.append(MyThread(target=func, args=('e:/', 3)))    for p in ThreadPool:        p.start()    for p in ThreadPool:        p.join()    df = pd.concat([p.result for p in ThreadPool])    df.to_csv('thread.csv', index=None)</code></pre><p>收工！</p><hr><p>码痴， coding 改变人生！</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python形参中*的作用(非*args**kwargs)</title>
      <link href="/myblog/2021/05/19/Python%E5%BD%A2%E5%8F%82%E4%B8%AD-%E7%9A%84%E4%BD%9C%E7%94%A8-%E9%9D%9E-args-kwargs/"/>
      <url>/myblog/2021/05/19/Python%E5%BD%A2%E5%8F%82%E4%B8%AD-%E7%9A%84%E4%BD%9C%E7%94%A8-%E9%9D%9E-args-kwargs/</url>
      
        <content type="html"><![CDATA[<p>因业务需求， 阅读了python多线程库threading源码。发现__init__函数是这样定义的</p><pre><code class="python">class Thread:    def __init__(self, group=None, target=None, name=None,                 args=(), kwargs=None, *, daemon=None):</code></pre><p>其中 * 瞬间打开了我新世界大门，因为按理说python不支持特殊字符作为变量名。</p><p>所有中文搜索引擎没有发现相关解释。 不得已去 栈溢出 网站看看外国大佬怎么说， 很幸运找到了解释。</p><p>根据PEP3102，* 的基本意义为， 在这个位置之后的参数必须用关键字参数(keyword arguement)作为输入。 其作用有两个:</p><h2 id="1-省略关键字参数的默认值"><a href="#1-省略关键字参数的默认值" class="headerlink" title="1) 省略关键字参数的默认值"></a>1) 省略关键字参数的默认值</h2><p>请看下面的简单例子</p><pre><code class="python">def func(arg1, arg2, *, arg3, arg4):    print('This is arg1: ' + arg1)    print('This is arg2: ' + arg2)    print('This is arg3: ' + arg3)    print('This is arg4: ' + arg4)func('arg1', 'arg2', 'arg3', 'arg4')</code></pre><p>返回</p><pre><code>Exception has occurred: TypeErrorfunc() takes 2 positional arguments but 4 were given</code></pre><p>这里是说func只需要2个位置参数(position arguements), 但是接到了4个。修改代码如下:</p><pre><code class="python">def func(arg1, arg2, *, arg3, arg4):    print('This is arg1: ' + arg1)    print('This is arg2: ' + arg2)    print('This is arg3: ' + arg3)    print('This is arg4: ' + arg4)func('arg1', 'arg2', arg3='arg3', arg4='arg4')</code></pre><p>返回</p><pre><code class="markdown">This is arg1: arg1This is arg2: arg2This is arg3: arg3This is arg4: arg4</code></pre><p>再来看看arg3， arg4 有没有关键字参数的打包解包(pack-unpack)性质</p><pre><code class="python">def func(arg1, arg2, *, arg3, arg4):    print('This is arg1: ' + arg1)    print('This is arg2: ' + arg2)    print('This is arg3: ' + arg3)    print('This is arg4: ' + arg4)kwarg = {'arg3':'arg3', 'arg4':'arg4'}func('arg1', 'arg2', **kwarg)</code></pre><p>返回</p><pre><code class="markdown">This is arg1: arg1This is arg2: arg2This is arg3: arg3This is arg4: arg4</code></pre><p>证明 arg3， arg4 确实是可以不赋默认值的关键字参数。下面来看第二个作用。</p><h2 id="2-避免-位置参数-和-关键字参数混用"><a href="#2-避免-位置参数-和-关键字参数混用" class="headerlink" title="2) 避免 位置参数 和 关键字参数混用"></a>2) 避免 位置参数 和 关键字参数混用</h2><p>有时候我们输入位置参数时， 会不小心多打， 导致关键字参数被输入错。</p><pre><code class="python">def func(arg1, arg2, arg3, arg4=False):    print('This is arg1: ' + arg1)    print('This is arg2: ' + arg2)    print('This is arg3: ' + arg3)    print('This is arg4: ' + arg4)func('arg1', 'arg2', 'arg3', 'arg3')</code></pre><p>返回</p><pre><code class="markdown">This is arg1: arg1This is arg2: arg2This is arg3: arg3This is arg4: arg3</code></pre><p>可以看到， 由于我们多输入了一个 ‘arg3’, 导致arg4接到了错误参数。修改代码如下：</p><pre><code class="python">def func(arg1, arg2, arg3, *, arg4=False):    print('This is arg1: ' + arg1)    print('This is arg2: ' + arg2)    print('This is arg3: ' + arg3)    print('This is arg4: ' + arg4)func('arg1', 'arg2', 'arg3', 'arg3')</code></pre><p>返回</p><pre><code class="markdown">func() takes 3 positional arguments but 4 were given</code></pre><p>有效防止了我们输入错误。</p><p>回到刚开始python threading 多线程库的问题,</p><pre><code class="python">class Thread:    def __init__(self, group=None, target=None, name=None,                 args=(), kwargs=None, *, daemon=None):</code></pre><p>这里声明了 daemon 一定要用关键字参数输入, 说明开发者认为这个参数十分重要。事实上， 这个daemon意思是守护线程的意思，和阻塞线程正好是两个相反的逻辑顺序。 本文不做深入讲解， 读者只需要知道这里daemon设置为True， False， 或者保持默认参数，会导致这个线程出现三个完全不同的运行状态， 因而要使用*来提醒用户避免输错。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://stackoverflow.com/questions/11365909/what-does-a-single-without-identifier-mean-in-the-python3-functions">What does a single * without identifier mean in the Python3 functions?</a></li><li>[2] <a href="https://www.python.org/dev/peps/pep-3102/">PEP 3102 – Keyword-Only Arguments</a></li><li>[3] <a href="https://stackoverflow.com/questions/59661042/what-do-single-star-and-slash-do-as-independent-parameters">What do * (single star) and / (slash) do as independent parameters?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH 隧道端口转发实现Jupyter Notebook远程访问服务器</title>
      <link href="/myblog/2021/05/18/SSH-%E9%9A%A7%E9%81%93%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0Jupyter-Notebook%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/myblog/2021/05/18/SSH-%E9%9A%A7%E9%81%93%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0Jupyter-Notebook%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Jupyter Notebook 在广大python用户，尤其是数据科学工作者中深受喜爱。其方便的交互性， 可视性特别适合数据分析。虽然笔者已经多年不以其作为主力python编辑环境，但实验室还是有人(数学背景出身，貌似搞数学的pythoner都特别喜欢jupyter)对其十分青睐。 身为实验室服务器运维的笔者， 自然要负责配置好jupyeter远程访问。网上所有的教程(包括官网)都千篇一律需要修改服务器本地jupyter_notebook_config.py, 而且绝大多数教程并没有按照官网建议的配置安全证书。笔者曾经历经千辛万苦配成功过，但踩坑无数，这里不再赘述。 偶然一次机会发现 ssh 隧道端口转发协议， 遂产生idea使用它来实现远程访问服务器。</p><p>&nbsp;</p><h2 id="一、SSH-隧道端口转发简介"><a href="#一、SSH-隧道端口转发简介" class="headerlink" title="一、SSH 隧道端口转发简介"></a>一、SSH 隧道端口转发简介</h2><p>SSH隧道的特点：</p><p>1、加密SSH客户端端至SSH服务器端之间的通讯数据</p><p>2、突破防火墙的限制完成一些之前无法建立的TCP连接</p><p>在本文应用场景下，简而言之就是jupyter notebook 在服务器终端启动时，会在服务器本地产生一个服务。我们需要做的就是通过 ssh 隧道转发协议，将服务器 jupyter 服务端口转发至我们本地机器上的端口， 从而进行远程访问。SSH 端口转发有三个选项：-L、-R和-D。这里我们用-L，即将远程(L)主机端口转发本地。</p><p>&nbsp;</p><h2 id="二、上机操作"><a href="#二、上机操作" class="headerlink" title="二、上机操作"></a>二、上机操作</h2><p>Linux OS：Ubuntu18.04</p><p>打开本地终端登录服务器，进入要使用的python环境(conda activate env)，输入  </p><pre><code>jupyter notebook --port=20000</code></pre><p>这里20000为远程端口， 读者可自定义。 返回如下(隐去真实路径信息)  </p><pre><code>(base) MatrixMan@server:~$ jupyter notebook --port=20000[I 19:56:22.007 NotebookApp] JupyterLab extension loaded from /your/path/to/anaconda3/lib/python3.8/site-packages/jupyterlab[I 19:56:22.007 NotebookApp] JupyterLab application directory is /your/path/to/anaconda3/share/jupyter/lab[I 19:56:22.011 NotebookApp] 启动notebooks 在本地路径: /your/path/to/boot[I 19:56:22.011 NotebookApp] 本程序运行在: http://iiplab-server:20000/[I 19:56:22.011 NotebookApp] 使用control-c停止此服务器并关闭所有内核(两次跳过确认).</code></pre><p>打开另一个终端(也可以使用nohup命令将jupyter挂在系统后台，就不用打开第二个终端)， 输入(隐去真实地址)  </p><pre><code>ssh -L localhost:2000:localhost:20000 MatrixMan@143.111.56.87</code></pre><p>如果配置过ssh 免密登录的话，此时已经可以在本地访问了。</p><p>打开浏览器， 输入</p><pre><code>http://localhost:2000/</code></pre><p><img src="/myblog/2021/05/18/SSH-%E9%9A%A7%E9%81%93%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0Jupyter-Notebook%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/f1.jpg" alt="效果图"><br>搞定！！！</p><hr><p>欢迎提出反馈意见， 批评指正.<br>矩阵侠， 分享工作学习中所见所闻， 欢迎交流！</p>]]></content>
      
      
      <categories>
          
          <category> 服务器运维 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
